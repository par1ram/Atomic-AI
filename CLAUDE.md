1. Основополагающие принципы

Ясность

Ясность — ключ к надёжному коду (из Swift API Design Guidelines).
Сложность маскирует ошибки и усложняет отладку.
Swift стремится к ясности через optionals и type safety, избегая неявных преобразований.


Безопасность

Код пишется для предотвращения ошибок, а не для их исправления (Брэд Апплтон).
Безопасный код легче тестировать, что критично для iOS/macOS-приложений.
Небезопасный код приводит к крашам, что может разрушить пользовательский опыт.


Производительность

Производительность — это баланс между скоростью и читаемостью.
Быстрая компиляция Swift (ARC, generics) повышает эффективность.
Единый стиль (SwiftFormat) упрощает ревью и выявление багов.




2. Идентификаторы
Идентификаторы (имена переменных, функций, типов) сильно влияют на читаемость.

Ясность, а не краткость

Хорошее имя: лаконичное, описательное, предсказуемое.
Имена должны объяснять назначение, а не реализацию (напр., averageAge, а не sumDividedByCount).


Длина идентификатора

Короткие имена (напр., p) для локальных, короткоживущих переменных.
Длинные имена для значимых, долгоживущих объектов.
Избегать включения типа в имя (напр., users вместо usersArray).
Однобуквенные переменные (i, j) для циклов, слова — для параметров и функций.


Не называйте по типам

Имя должно описывать содержимое, а не тип (напр., users вместо usersArray).
Избыточные суффиксы (Array, Optional) не нужны, так как типы проверяет компилятор.


Единый стиль именования

Предсказуемые имена (напр., db для Database везде).
Одинаковые имена параметров для методов одного протокола.
Традиции: i, j для циклов, value для значений, key для ключей.


Единый стиль деклараций

Используйте let для констант, var для изменяемых значений.
Указывайте тип явно для сложных случаев (напр., let length: UInt32 = 0x80).
Предпочитайте инициализацию без опционалов.


Работайте на коллектив

Следуйте стилю команды, даже если он отличается от личных предпочтений.
Единообразие важнее личных вкусов; используйте SwiftFormat.
Не смешивайте переименования с другими изменениями в коде.




3. Комментарии
Комментарии должны быть полезными и лаконичными.

Роль комментариев

Объяснять:

Что делает код (для публичных символов).
Как он работает (внутри метода).
Почему написан так (внешние факторы).


Комментарии к переменным/константам описывают содержимое, а не назначение.


Документируйте публичные символы

Все публичные переменные, функции, методы должны иметь документацию для Quick Help.
Исключение: методы, реализующие протокол, не нуждаются в комментариях.
Пишите комментарий перед функцией, чтобы уточнить её цель (/// формат).


Переписывайте плохой код вместо комментирования

Плохой код с комментариями хуже, чем переписанный ясный код.
Используйте TODO с именем/датой для технического долга.
Рефакторинг функции может устранить необходимость в комментариях.




4. Структура модуля
Модули — это мини-приложения, минимизирующие связность.

Хорошее название модуля

Название отражает функциональность, а не содержимое (напр., Networking, а не Client).
Уникальные имена предотвращают дублирование.


Избегайте общих названий

Названия вроде Base, Common, Util неинформативны.
Перемещайте функции из Utils в вызывающие модули или создавайте специализированные (напр., Foundation.String).
Объединяйте клиентский и серверный код в одном модуле (напр., URLSession).


Быстрый возврат

Используйте guard для раннего возврата (guard let value = optional else { return }).
Это улучшает читаемость, избегая глубокой вложенности.


Полезное значение по умолчанию

Структуры должны быть готовы к использованию без инициализации (напр., Date, URL).
Методы на nil-опционалах могут задавать значения по умолчанию.


Избегайте состояния уровня модуля

Глобальные переменные создают тесную связанность.
Решения:

Перемещайте переменные в структуры.
Используйте протоколы для поведения.






5. Структура проекта
Проект — это единый репозиторий с чёткой целью.

Меньше, но крупнее модулей

Избегайте избыточного дробления на мелкие модули.
В Swift уровни доступа: public, internal, private.
Модуль Swift эквивалентен фреймворку, а не пакету.
Каждый модуль (кроме Sources/ и Tests/) должен содержать код.
Организуйте файлы по функциональности (напр., Client.swift, Server.swift).
Предпочитайте unit-тесты для модульного тестирования.


Минимальный App

App должен только парсить опции, открывать соединения и передавать управление.
Логика в App затрудняет тестирование.


Внутренние модули

Используйте папку Internal/ для кода, доступного только внутри проекта.
Это уменьшает публичный API.




6. Структура API
API должны быть простыми и устойчивыми к ошибкам.

Трудно злоупотреблять

API должны быть интуитивными и защищёнными от неправильного использования.
Избегайте функций с несколькими параметрами одного типа (напр., copyFile(to: from: String)).
Решение: вводите вспомогательные типы (напр., Source для copyFile).


Для основного сценария

API не должны требовать лишних параметров (напр., nil в URLSession).
Избегайте nil как параметр, чтобы предотвратить путаницу.
Используйте trailing closures вместо массивов для гибкости.


Протоколы определяют поведение

Используйте протоколы для описания поведения (напр., Sequence вместо Array).
Принцип разделения интерфейса: минимизируйте требования (напр., Equatable вместо Comparable).




7. Обработка ошибок
Ошибки должны быть минимальными и обрабатываться однократно.

Устраняйте ошибки

Лучший способ обработки ошибок — их отсутствие.
Пример: замена опционалов на non-optionals упрощает код.
Вспомогательные типы (напр., Result) могут скрывать обработку ошибок.


Обрабатывайте ошибку один раз

Игнорирование ошибок или множественная обработка (лог + throw) — ошибки.
Добавляйте контекст с Error.localizedDescription для трассировки.
Избегайте логирования и бросания одновременно, чтобы не дублировать ошибки.




8. Параллелизм
Параллелизм — мощная, но сложная функция Swift.

Выполняйте работу

Избегайте пустых циклов (while true {}).
Запускайте работу в основной задаче, если нет необходимости в параллелизме.
Умеренность в использовании Task.


Оставьте параллелизм вызывающей стороне

Предпочитайте async/await вместо callbacks для асинхронных API.
Actors упрощают thread-safety.
Дайте вызывающему объекту управлять задачами.


Контролируйте остановку задач

Всегда знайте, когда задача завершится.
Используйте CancellationToken для graceful shutdown.
Пример: хелпер с Task для async HTTP-запросов.
Избегайте fatalError вне main, используйте throws.
